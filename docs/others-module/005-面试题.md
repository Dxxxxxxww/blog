## b 站一面

1. offsetWidth 是多少，不同浏览器下，如何展示的，怎么切换

2. margin-top: -10px margin-bottom: -20px 会怎么展示

3. bfc

4. flex ooo 变 九宫格

5. flex: 1 代表啥

6. rem 怎么设置

7. 类型判断

8. 值类型和引用类型如何存储

9. 深拷贝，正则如何拷贝

10. InstanceOf

11. Promise 任务的题

12. click 是微任务还是宏任务

13. addevnentlister 参数

14. currentTarget 和 target 区别

15. ```javascript
    function double(x) {
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve(x)
        }, 1000)
      })
    }

    function test() {
      const nums = [1, 2, 3, 4, 5, 6, 7, 8]
      nums.forEach(async (item) => {
        const x = await double(item)
        console.log(x)
      })
    }

    test()
    // 传入一个数组会怎么输出
    // 怎么变成另外一种
    ```

16. promise.race

17. created、mounted、beforeUpdate、updated、destoryed 父子组件执行顺序

18. v-for 和 v-if 一起使用，优先级，如何解决

19. v-model 封装

20. .sync 什么用

21. 动态组件是啥

22. keep-alive 生命周期

## 小红书一面

1.问了事件循环

2.问了缓存 cache 缓存怎么配置

3.问了用户反馈页面卡顿 从哪几个方面进行排查 用什么工具 然后问解决方案

4.项目中做了哪些优化

5.一堆输入输出题 和 代码 bug 题

6. BFF 和 Serverlsee

你了解 BFF 吗？

有什么应用 或者 有什么利弊？ 怎么看待 BFF 的发展

Serverlsee 解决了哪些问题？

Serverlsee 目前有哪些发展 有哪些解决方案？

没问关于框架或者源码的

##

webpack 优化

hooks 原理

hooks 限制

为什么引入 fiber

他可中断更新是怎么做的

优先级调度是如何控制的

diff 算法的流程

##

this

keep-alive 的原理。

webpack plugin loader 的区别。

cdn 是怎么保证文件唯一性的。

网络

网络安全-》中间人攻击

ownkeys 是自身上所有的，包括 symbol
keys 是自身上所有可以枚举的并不包括 symbol

Number.isNaN 和 isNaN 的区别？
答： isNaN 会做隐式转换，尝试转换成 number，Number.isNaN 不会

```js
console.log(Number.isNaN(1))
console.log(Number.isNaN(''))
console.log(Number.isNaN(true))
console.log(Number.isNaN(false))
console.log(Number.isNaN(undefined))
console.log(Number.isNaN(null))
console.log(Number.isNaN({}))
console.log(Number.isNaN([]))
console.log(Number.isNaN(new Set([])))
console.log(Number.isNaN(new Map()))
console.log(Number.isNaN(Symbol()))
console.log(Number.isNaN(BigInt(1)))
// 以上全是 false
console.log(Number.isNaN(NaN)) // true

// isNaN 会做隐式转换，所以要思考下那些值转为 number 会有问题。Number()
console.log(isNaN(1)) // false
console.log(isNaN('')) // false
console.log(isNaN(true)) // false
console.log(isNaN(false)) // false
console.log(isNaN(undefined)) // true
console.log(isNaN(null)) // false
console.log(isNaN({})) // true
console.log(isNaN([])) // false
console.log(isNaN(new Set([]))) // true
console.log(isNaN(new Map())) // true
// console.log(isNaN(Symbol()))   // 报错 Cannot convert a Symbol value to a number
// console.log(isNaN(BigInt(1)))  // 报错 Cannot convert a BigInt value to a number
console.log(isNaN(NaN)) // true
```

## 字节一面

字节编程题考了三道

1. 一道写泛型
2. 一道考了事件循环机制+浏览器渲染机制。
3. 实现 promise.all，还要加一个参数 limit 限制 同时请求的数量，

- t1 100ms
- t2 200ms
- t3 300ms
- t4 400ms
  几个任务经过一些时间后开始请求。
  基础题：

1. 聊项目做了哪些模块
2. 讲 hash 路由 和 history 路由的区别，原理是什么？怎么做的选型？
   这题可以通过简单手写的路由那里总结下，原理就是监听 history api。做选型就得看后端/运维配合不配合搞 history 模式了
3. 微前端怎么做通信
4. iframe 和 微前端 怎么做选型
5. 单点登录
6. css js 怎么做的沙箱隔离
7. 有没有做过 css 的性能优化

## event-loop

```js
// 执行环境以 Chrome 为准
// 第一组
async function async1() {
  console.log('async1 start')
  await async2()
  console.log('async1 end')
}
async function async2() {
  console.log('async2')
}
console.log('script start')
setTimeout(function () {
  console.log('setTimeout')
}, 0)
async1()
new Promise((resolve) => {
  console.log('promise1')
  resolve()
}).then(function () {
  console.log('promise2')
})
console.log('script end')

// script start, async1 start, async2, promise1, script end, async1 end, promise2, setTimeout

// 第二组
async function async1() {
  console.log('async1 start')
  await async2()
  console.log('async1 end')
}
async function async2() {
  new Promise(function (resolve) {
    console.log('promise1')
    resolve()
  }).then(function () {
    console.log('promise2')
  })
}
console.log('script start')
setTimeout(function () {
  console.log('setTimeout')
}, 0)
async1()
new Promise(function (resolve) {
  console.log('promise3')
  resolve()
}).then(function () {
  console.log('promise4')
})
console.log('script end')

// script start,  async1 start,  promise1,  promise3,  script end,  promise2,  async1 end,  promise4,  setTimeout

// 第三组
async function async1() {
  console.log('async1 start')
  await async2()
  setTimeout(function () {
    console.log('setTimeout1') // 3
  }, 0)
}
async function async2() {
  setTimeout(function () {
    console.log('setTimeout2') // 2
  }, 0)
}
console.log('script start')
setTimeout(function () {
  console.log('setTimeout3') // 1
}, 0)
async1()
new Promise(function (resolve) {
  console.log('promise1')
  resolve()
}).then(function () {
  console.log('promise2')
})
console.log('script end')

// script start,  async1 start,  promise1,  script end,  promise2,  setTimeout3,  setTimeout2,  setTimeout1
```

## 继承

ES5 构造函数与 ES6 类有啥区别

JavaScript 的函数和对象是怎样的关系？

`__proto__` 和 prototype 都表示原型对象，它们有什么区别呢？

JavaScript 中对象的继承和原型链是什么关系？

[ES5 继承](https://github.com/mqyqingfeng/Blog/issues/16)

## 字节 3 面

字节三面： 4.你写的这个排序算法能大概讲讲你的出发点吗？
5.v8 排序了解吗做了什么处理？ 6.为什么 v8 要这么处理 7.插入排序实现原理 8.快速排序实现原理 9.快速排序的缺点是什么？ 10.什么是排序稳定性？ 11.洗牌算法是什么？ 12.这几个算法的时间复杂度是多少，稳定性是什么？

## 粉象 2 面

1. 项目性能优化
2. 前端安全

## 丁香园 1 面

1. http 状态码（204 206 301 302 304 401 403 404） HTTP HTTPS [厂神 http](https://juejin.cn/post/6996175213570293791) 记的时候可以打开 淘宝，看 network，看 all
2. xss csrf 前端安全，http https，然后为什么 https 比较安全，还有三次握手的作用
3. 性能优化能说多少说多少
4. vue2 和 3 的区别。鸡哥回答：写法不同 optionsapi 和 composition api。 响应式上的区别。原理上不同的多了 proxy defineproperty 就能讲很多吧。
   峰哥回答：最主要的是核心 原理 啊 proxy 改进了响应式。不怕 数组和未定义的对象属性了。
   diff。性能提升->静态节点提升。
5. 内存泄漏的有哪些。标答是 4 种，闭包的引用未清空，使用了未声明的变量会一直在全局中，定时器，dom 引用未删除，事件监听移除，对应变量移除
6. 项目问题

## 丁香园二面

1. 手写题
2. map 和 foreach 会改变原数组吗
   a. 鸡：基础类型不变，引用类型改变（ps 引用类型应该啥循环都会改吧）
   b. 冬瓜：forEach/map 基础类型得用第三个参数（已证实，第三个参数，数组引用是可以改变的。）

   ```js
   var a = [1, 2, 3]
   a.forEach((v, i, arr) => {
     arr[i] = v + 1
   })
   // a: [2,3,4]
   ```

3. loader 是怎么处理二进制文件的，类似 mp3 这种打包后是怎么样的
   a. 茂茂：loader 处理二进制是复制到 dist 文件夹然后返回路径地址
   b. 峰哥：跟图片一样啊，想想图片咋处理的
   c. 鸡哥：我说打包后还是独立文件，通过连接去找到这个文件的。就是你打包后，mp3 是二进制文件，他不可能打包进 js 吧。那就是引用的地方 怎么处理连接到 mp3 在当前打包后文件的地址了，我是这么想的。我就是想到了，打包后的图片。就是给加个链接。
4. h5 点击穿透， 300ms 问题。

## 政采云 1 面

1. 面政采云一直问 cdn 的原理，
2. http 安全
3. webpack 源码

## 字节 1 面

1. 小程序出现了长列表优化，那为什么 h5 这方面不会有这个问题，渲染上小程序和 h5 有啥不同。小程序渲染和 h5 有啥不同，引起了一些啥问题。

## 网易 1 面

1. 手写题：throttle， es5 class 实现（es5 实现的原理） Object.create 实现原理。
2. vue-router /a/b/c componentA-->componentB-->componentC router-view 内部怎么做匹配的
   a. tang：先匹配 c 啊，然后找 parent，push 到一个数组里面。
   b. 瓜： 有个 match 方法
   c. 茂：[源码](https://ustbhuangyi.github.io/vue-analysis/v2/vue-router/matcher.html#creatematcher)
3. 低代码，组件联动，oa 端必有的，就是 c 组件里有个东西，通过 ab 组件的值，比如 1+1》2 的时候 c 组件就不显示啥，低代码要反应到 json，这个算是 拖拽表单的难点了 数据联动。
   a. 厂：在 a 组件里面传回调函数出来，然后在业务逻辑通过回调函数修改 b 组件 props
4. template 怎么渲染的，如何解析 template。
   a. tang: 只知道正则匹配，匹配到标签名，属性 跟方法，通过栈的方式，匹配首尾标签 子节点，然后构成 ast。
5. promise 输出题目

```js
console.log('A')

async function async1() {
  await async2()
  console.log('B')
}

async function async2() {
  console.log('C')
}

setTimeout(() => {
  console.log('D')
}, 0)

async1()

new Promise((resolve) => {
  setTimeout(() => {
    console.log('F')
  }, 0)
  console.log('E')
  resolve()
})
  .then(() => {
    console.log('G')
  })
  .then(() => {
    console.log('H')
  })

console.log('I')

// A C E I B G H D F
// 茂茂：
// 其实就是这样的，在执行完 await 后跳出 async 函数去执行其他同步代码，等同步代码执行完毕以后将 async 函数中未执行的代码注册成微任务，具体要看你的 await 后面还有没有代码，没有代码就没有注册微任务这一步了。

// async 输出你理解这一段就好了

// async 函数在执行完 await 后会跳出 async 函数去执行其他同步代码，等同步代码执行完毕以后将 async 函数中未执行的代码注册成微任务
```

![image](/js/async-promise.png)

[async 搜索由于因为](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7)

[这种输出题照着这两个文章学就行了](https://juejin.cn/post/6945319439772434469)

## 阅文 1 面

1. cjs esm 区别。循环引用。然后问你 wp5 支持 cjs 的 tree shaking 是如何做到的。
   a. [深入 CommonJs 与 ES6 Module](https://segmentfault.com/a/1190000017878394)
   b. [ESModule 加载与运行机制](https://mp.weixin.qq.com/s/wxUz5E1Xs5dqYFPRPOnAlw)
2. vue 事件是怎么处理的，怎么监听的。与 react 的区别。
   a. 冬瓜：vue 事件最终会绑定在组件的 \_events 中，
3. 事件委托
   a. 茂：事件委托一般都用在元素会有动态添加的场景，这样不用再去手动绑定。
4. 优化。

## cvte 1 面

1. http 历程，协商缓存。
2. flex 1 bfc。
3. vue，react 区别。
4. 防抖节流，箭头函数，promise，async...await，const let var。
5. 平时开发用的设计模式。
6. 性能优化。
7. 一个大屏设备场景：宽高 100%，内容不确定多少，不能出现横纵滚动条，如何设置。
   a. 三爷：不看到滚动条，还要滚动，可以用 bs
   b. 汪：最顶层 width:100% height: 100%，剩下就是 flex 按设计稿来切图
   c. 鸡：可以使用 moveable，拖拽。

## 伯约面试题

1. 面试题。涉及 HotReload 原理？面试官后来提示用 socket。（另，HMR 和 HotReload 是同一个意思吗？见好多种说法）
   a. 开发时，保存的代码，会经过 webpack 打包成模块，生成 chunk，然后通过 websocket 传输给浏览器，浏览器那边接收后会根据情况做替换。如果开启了 hmr，那么会模块级替换，如果没开启 hmr，有的会默认刷新页面。根据打包的模块 id 进行查找替换，实现 hmr。一般来说，前端 js 的 hmr 确实实现上麻烦些。但是样式的就好实现很多。样式你要替换就去抹掉 style 标签内容就行。

   React Hot Loader: 实时调整 react 组件。
   Vue Loader: 此 loader 支持 vue 组件的 HMR，提供开箱即用体验。

   HMR 是 Hot Module Replacement
   Hot Reload 是热更新。

   HotReload 应该是 包含了 hmr 的。

   Q: 这个 websocket 是第一次本地运行就建立好是吗？看到 Hot ModuleReplacePlugin 好像是会生成上一次的 json 和 js 文件？具体作用是用来模块替换吗?

   A: 对，webpack 会启动一个 express server，并启动一个 websocket 链接。打开网页后，你访问的是 express server 吐出来的 html。然后页面会默认联通一个 websocket。你打开 network 看 ws 那里，能看到。是明文传输的内容。JSON 是模块描述文件（更新文件的清单），js 是 chunk 更新模块。

   Q：那浏览器会做什么处理？

   A：浏览器执行的是 webpack 的 express 吐出来的 html。html 上会挂一个 webpack 的 js。里面的逻辑是去连 websocket，接收数据，然后浏览器去拉 \_\_webpack_hmr 更新。

   Q: network 中的 \_\_webpack_hmr 是啥东西

   A: 这个是 ws 推消息给浏览器那边儿，相当于 ws 给浏览器说，来有个更新，你去读这个地址，然后浏览器去拉 \_\_webpack_hmr 更新。

   可以在 network 中的 ws 选项卡中看到 websocket，vue 项目看不到，react 项目看得到。

   ![image](/other/ws1.png)
   ![image](/other/ws2.png)
   ![image](/other/ws3.png)
   [资料 1](https://stackoverflow.com/questions/40889776/what-are-the-conceptual-differences-between-live-reloading-hot-reloading-and-h)
   [资料 2](https://stackoverflow.com/questions/24581873/what-exactly-is-hot-module-replacement-in-webpack)
   [资料 3](https://zhuanlan.zhihu.com/p/30669007)

## iife

```js
// 为什么 b 会变成 20，而 a 不会
// 这是因为在 iife 中，函数名当做常量来处理，不可修改，加严格模式就能看到报错了
var a = 10
var b = 10
;(function a() {
  b = 20
  console.log(b) // 20
  a = 20
  console.log(a) // 函数 a
})()

a // 10
b // 20
```

```js
var a = 10
var b = 10
;(function a() {
  'use strict'
  b = 20
  console.log(b) // 20
  a = 20
  console.log(a) // 函数 a
})()

// Uncaught TypeError: Assignment to constant variable.at a
```

[资料](https://segmentfault.com/q/1010000002810093)

## 立即执行函数的使用场景

sandbox 沙箱应该就可以用 IIFE 做点处理吧(不过感觉最方便的就是用 iframe 简单粗暴，我看 MDN 就是这么用的)

## 明康汇

1. 是 tree 孙子节点快速找爷爷节点

```js
let tree = {
  id: 1,
  name: '我是第一级',
  children: [
    {
      id: 2,
      name: '我是第二级-a',
      children: [
        { id: 3, name: '我是第三级-a' },
        { id: 4, name: '我是第三级-b' },
        { id: 5, name: '我是第三级-c' }
      ]
    },
    {
      id: 6,
      name: '我是第二级-b',
      children: []
    }
  ]
}

// 通过子节点id，获取这个节点的所有父级id
// 输入：id 为 4
// 希望返回 [1,2,4]
```

a. 鸡：后端+字段，直接把父级 id 挂载到子级上。parent: '1-2'
b. 鸡：递归（不推荐）
c. 鹏：搞个栈，进一层就 push 一层，找到就返回，reverse 一下，跳出就 pop，进入下一个 child 的 push 工作。回溯算法。

2. 微信小程序/h5 的 token 过期了，要无感知的更新 token，重新请求失败接口。
   a. 鸡：请求前或者请求后缓存失败的请求，如果 token 过期了，就请求新的 token，再遍历缓存的失败接口进行请求。茂：那个无感知刷新有点扯，你缓存请求也没用，请求之后的回调你如何再去调用，统一管理没办法搞的，只能特殊情况特殊处理。
   b. 鸡：正常来说就是放到 redis，然后用的时候后端刷新续 2h，长时间不用就该让他登录。但是不安全啊，一直刷新。最好其实还是就要重新登录。
   c. 8: 如果小程序或者 H5，没有对接微信授权，那和普通的 token 失效没有区别，如果对接了微信授权，就需要根据授权给 code，后端去刷新这个 code。微信这种更安全，在前端小程序的刷新 token 就是 调用 wxlogin 吧获得的 code 传给后端就好了。授权对接文档不是写了，要根据 code，刷新 token。

## 虾皮

1. 说一下 options 请求
2. xss 攻击
3. <https://juejin.cn/post/6860646761392930830>

## 美团

1. 说下跨域，说下 jsonp

## 跨域请求在服务端会不会执行？

简单请求：不管是否跨域只要发出去了，一定会到达服务端并被执行，浏览器只会隐藏返回值
复杂请求：先发预检预检不会真正执行业务逻辑预检通过后才会发送真正请求并在服务端被执行

## ts 相关

type interface 区别
ts 优劣和库的 types
写点基本的类型体操
怎么通过接口生成声明
装饰器原理
