## b 站一面

1. offsetWidth 是多少，不同浏览器下，如何展示的，怎么切换

2. margin-top: -10px margin-bottom: -20px 会怎么展示

3. bfc

4. flex ooo 变 九宫格

5. flex: 1 代表啥

6. rem 怎么设置

7. 类型判断

8. 值类型和引用类型如何存储

9. 深拷贝，正则如何拷贝

10. InstanceOf

11. Promise 任务的题

12. click 是微任务还是宏任务

13. addevnentlister 参数

14. currentTarget 和 target 区别

15. ```javascript
    function double(x) {
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve(x)
        }, 1000)
      })
    }

    function test() {
      const nums = [1, 2, 3, 4, 5, 6, 7, 8]
      nums.forEach(async (item) => {
        const x = await double(item)
        console.log(x)
      })
    }

    test()
    // 传入一个数组会怎么输出
    // 怎么变成另外一种
    ```

16. promise.race

17. created、mounted、beforeUpdate、updated、destoryed 父子组件执行顺序

18. v-for 和 v-if 一起使用，优先级，如何解决

19. v-model 封装

20. .sync 什么用

21. 动态组件是啥

22. keep-alive 生命周期

## 小红书一面

1.问了事件循环

2.问了缓存 cache 缓存怎么配置

3.问了用户反馈页面卡顿 从哪几个方面进行排查 用什么工具 然后问解决方案

4.项目中做了哪些优化

5.一堆输入输出题 和 代码 bug 题

6. BFF 和 Serverlsee

你了解 BFF 吗？

有什么应用 或者 有什么利弊？ 怎么看待 BFF 的发展

Serverlsee 解决了哪些问题？

Serverlsee 目前有哪些发展 有哪些解决方案？

没问关于框架或者源码的

##

webpack 优化

hooks 原理

hooks 限制

为什么引入 fiber

他可中断更新是怎么做的

优先级调度是如何控制的

diff 算法的流程

##

this

keep-alive 的原理。

webpack plugin loader 的区别。

cdn 是怎么保证文件唯一性的。

网络

网络安全-》中间人攻击

ownkeys 是自身上所有的，包括 symbol
keys 是自身上所有可以枚举的并不包括 symbol

Number.isNaN 和 isNaN 的区别？
答： isNaN 会做隐式转换，尝试转换成 number，Number.isNaN 不会

```js
console.log(Number.isNaN(1))
console.log(Number.isNaN(''))
console.log(Number.isNaN(true))
console.log(Number.isNaN(false))
console.log(Number.isNaN(undefined))
console.log(Number.isNaN(null))
console.log(Number.isNaN({}))
console.log(Number.isNaN([]))
console.log(Number.isNaN(new Set([])))
console.log(Number.isNaN(new Map()))
console.log(Number.isNaN(Symbol()))
console.log(Number.isNaN(BigInt(1)))
// 以上全是 false
console.log(Number.isNaN(NaN)) // true

// isNaN 会做隐式转换，所以要思考下那些值转为 number 会有问题。Number()
console.log(isNaN(1))             // false
console.log(isNaN(''))            // false
console.log(isNaN(true))          // false
console.log(isNaN(false))         // false
console.log(isNaN(undefined))     // true
console.log(isNaN(null))          // false
console.log(isNaN({}))            // true
console.log(isNaN([]))            // false
console.log(isNaN(new Set([])))   // true
console.log(isNaN(new Map()))     // true
// console.log(isNaN(Symbol()))   // 报错 Cannot convert a Symbol value to a number
// console.log(isNaN(BigInt(1)))  // 报错 Cannot convert a BigInt value to a number
console.log(isNaN(NaN))           // true
```

## 字节一面

字节编程题考了三道

1. 一道写泛型
2. 一道考了事件循环机制+浏览器渲染机制。
3. 实现 promise.all，还要加一个参数 limit 限制 同时请求的数量，

- t1 100ms
- t2 200ms
- t3 300ms
- t4 400ms
  几个任务经过一些时间后开始请求。
  基础题：

1. 聊项目做了哪些模块
2. 讲 hash 路由 和 history 路由的区别，原理是什么？怎么做的选型？
   这题可以通过简单手写的路由那里总结下，原理就是监听 history api。做选型就得看后端/运维配合不配合搞 history 模式了
3. 微前端怎么做通信
4. iframe 和 微前端 怎么做选型
5. 单点登录
6. css js 怎么做的沙箱隔离
7. 有没有做过 css 的性能优化

## event-loop

```js
// 执行环境以 Chrome 为准
// 第一组
async function async1() {
  console.log('async1 start')
  await async2()
  console.log('async1 end')
}
async function async2() {
  console.log('async2')
}
console.log('script start')
setTimeout(function () {
  console.log('setTimeout')
}, 0)
async1()
new Promise((resolve) => {
  console.log('promise1')
  resolve()
}).then(function () {
  console.log('promise2')
})
console.log('script end')

// script start, async1 start, async2, promise1, script end, async1 end, promise2, setTimeout

// 第二组
async function async1() {
  console.log('async1 start')
  await async2()
  console.log('async1 end')
}
async function async2() {
  new Promise(function (resolve) {
    console.log('promise1')
    resolve()
  }).then(function () {
    console.log('promise2')
  })
}
console.log('script start')
setTimeout(function () {
  console.log('setTimeout')
}, 0)
async1()
new Promise(function (resolve) {
  console.log('promise3')
  resolve()
}).then(function () {
  console.log('promise4')
})
console.log('script end')

// script start,  async1 start,  promise1,  promise3,  script end,  promise2,  async1 end,  promise4,  setTimeout

// 第三组
async function async1() {
  console.log('async1 start')
  await async2()
  setTimeout(function () {
    console.log('setTimeout1') // 3
  }, 0)
}
async function async2() {
  setTimeout(function () {
    console.log('setTimeout2') // 2
  }, 0)
}
console.log('script start')
setTimeout(function () {
  console.log('setTimeout3') // 1
}, 0)
async1()
new Promise(function (resolve) {
  console.log('promise1')
  resolve()
}).then(function () {
  console.log('promise2')
})
console.log('script end')

// script start,  async1 start,  promise1,  script end,  promise2,  setTimeout3,  setTimeout2,  setTimeout1
```

## 继承

ES5 构造函数与 ES6 类有啥区别

JavaScript 的函数和对象是怎样的关系？

`__proto__` 和 prototype 都表示原型对象，它们有什么区别呢？

JavaScript 中对象的继承和原型链是什么关系？

[ES5 继承](https://github.com/mqyqingfeng/Blog/issues/16)

## 字节 3 面

字节三面： 4.你写的这个排序算法能大概讲讲你的出发点吗？
5.v8 排序了解吗做了什么处理？ 6.为什么 v8 要这么处理 7.插入排序实现原理 8.快速排序实现原理 9.快速排序的缺点是什么？ 10.什么是排序稳定性？ 11.洗牌算法是什么？ 12.这几个算法的时间复杂度是多少，稳定性是什么？
