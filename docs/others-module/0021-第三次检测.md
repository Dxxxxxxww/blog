2. 写出输出的结果（0% 正确率）

```js
// 第一组
function Foo() {
  getName = function () {
    console.log(1)
  }
  return this
}
var getName
function getName() {
  console.log(5)
}
Foo.getName = function () {
  console.log(2)
}
Foo.prototype.getName = function () {
  console.log(3)
}
getName = function () {
  console.log(4)
}

Foo.getName() // ？2
getName() // ？4
Foo().getName() // ？ 1
getName() // ？1
new Foo.getName() // ? 2
new Foo().getName() // ? 1
new new Foo().getName() // ？ ？？？

// 第二组
var x = [typeof x, typeof y][1]
console.log(typeof x) // string

// 第三组
console.log(
  (function (x) {
    delete x
    return x
  })(1)
) // 1

// 第四组（这一个很难）
var b = 10
;(function b() {
  b = 20
  console.log(b)
})() // 函数b

// 第五组
var a = 10
;(function () {
  console.log(a)
  a = 5
  console.log(window.a)
  var a = 20
  console.log(a)
})() // undefined 10 20

// 第六组（这个也很难）
var a = { n: 1 }
var b = a
a.x = a = { n: 2 }

console.log(a.x) // { n: 2 }
console.log(b.x) // { n: 2 }
```

3. script 标签上写 defer 与 async 有什么作用？与把 js script 放置于 body 尾部有什么区别？（41.67% 正确率）

defer：遇到 script 后不阻塞 dom 加载，并行下载 script，等 dom 加载完成后执行 script。

async：遇到 script 后不阻塞 dom 加载，并行下载 script，等 script 加载完成后暂停 dom 加载，执行 script。

script 放到最后是等到 dom 加载完才遇到 script，是一种方式 script 加载阻塞 dom 的手段。区别在于并行下载 script。

4. 关于浏览器，从 URL 输入，到页面的完全展现，都经历了什么？（75% 正确率）

一、浏览器判断是不是一个网址，如果不是，使用默认搜索引擎搜索。如果是，则用 dns 去查找域名对应的网址。
二、dns 找到对应的网址，查看是否命中强缓存，如果没有命中，开始建立连接。
三、建立 tcp/ip 通信连接，三次握手。
四、发送 http 请求，如果命中协商缓存，则返回数据状态码为 304，否则 200。
五、关闭 tcp 连接。(这里有个问题，如果我网页一直打开，tcp 连接是不是一直连着的？长连接)
六、加载 dom 建立 dom 树，加载 css 建立 css 树，合成渲染层，渲染页面。

5. ES5/ES6 的继承除了写法以外还有什么区别？（16.67% 正确率）

不知道。

6. 实现 a 让如下代码成立（58.33% 正确率）

```js
// var a = ?

// if (a == 1 && a == 2 && a == 3) {
//   console.log(1);
// }

// 方法1

var a = {
  i: 1,
  valueOf() {
    return this.i++
  }
  // toString() {
  //   return this.i++
  // }
}

if (a == 1 && a == 2 && a == 3) {
  console.log(1)
}

// 方法2

// var _a = 1

// Object.defineProperty(window, 'a', {
//   get() {
//     return _a++
//   }
// })

// if (a == 1 && a == 2 && a == 3) {
//   console.log(1);
// }
```

7. 介绍下 BFC 及其应用（66.7% 正确率）

BFC 就是盒子模型，浏览器在渲染元素时，会将元素看做一个盒子，这个盒子模型包括，margin, padding, border, content。

应用：

- 解决相邻盒子 margin 合并；
- 清除浮动造成的高度坍塌；

8. 实现 convert 方法，把原始 list 转换成树形结构，要求尽可能降低时间复杂度（33.33% 正确率）

```js
 // 原始 list 如下
    let list =[
    {id:1,name:'部门 A',parentId:0},
    {id:2,name:'部门 B',parentId:0},
    {id:3,name:'部门 C',parentId:1},
    {id:4,name:'部门 D',parentId:1},
    {id:5,name:'部门 E',parentId:2},
    {id:6,name:'部门 F',parentId:3},
    {id:7,name:'部门 G',parentId:2},
    {id:8,name:'部门 H',parentId:4}
    ];
    const result = convert(list, ...);
```

```js
let list = [
  { id: 1, name: '部门 A', parentId: 0 },
  { id: 2, name: '部门 B', parentId: 0 },
  { id: 3, name: '部门 C', parentId: 1 },
  { id: 4, name: '部门 D', parentId: 1 },
  { id: 5, name: '部门 E', parentId: 2 },
  { id: 6, name: '部门 F', parentId: 3 },
  { id: 7, name: '部门 G', parentId: 2 },
  { id: 8, name: '部门 H', parentId: 4 }
]

function convert(list) {
  const _map = {}
  const res = []
  list.forEach((item) => {
    _map[item.id] = item
  })

  list.forEach((item) => {
    if (item.parentId === 0) {
      res.push(item)
    } else {
      const parentItem = _map[item.parentId]
      if (parentItem) {
        parentItem.children = parentItem.children ?? []
        parentItem.children.push(item)
      }
    }
  })

  return res
}

const result = convert(list)
console.log(result)
```

9.React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？ （16.67% 正确率）

不知，performance.now()？

10. 为什么会出现跨域的问题？有什么跨域的解决方案？（33.33% 正确率）

浏览器为了安全。cors，jsonp。

11. 最近在学什么？谈谈你 3 ～ 5 年的职业规划。

最近在学 react，vue 源码。打算用 react + ts + node 做个练手项目。

短期规划是掌握 react，node。

长期规划，其实只想在杭州拿个 25k，不咋加班的工作。说实话前端方向可视化，node 脚手架基础工具服务，大前端，其实也没有想好要走哪一块。
