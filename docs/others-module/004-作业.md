# 作业

## this 指向

js 中调用函数一般会有以下 4 中情况：

1. 函数独立调用，在非严格模式下，this 指向 window，严格模式下指向 undefined。

```js
var a = 1
function fun() {
  return this.a
}
console.log(fun()) // 1
```

2. 作为对象的方法调用，this 指向对象。

```js
var a = 1
var obj = {
  a: 2,
  b: function () {
    return this.a
  }
}
console.log(obj.b()) // 2
```

3. call/apply/bind 调用，指向传入的对象。注意：当入参是 null/undefined 时，this 仍然指向 window。当入参是基本类型值时，会隐式转换成对应类型的对象。

```js
var obj = {
  a: 2
}
var a = 10
function b() {
  console.log(this.a)
}
console.log(b()) // 10
console.log(b.call(obj)) // 2
```

4. 作为构造函数调用，指向 new 出来的对象。注意：如果构造函数中返回了其他对象，this 会指向其他对象。如果 return null/undefined/基本类型值 ，this 还是会指向新建的对象。

```js
var a = 10
function Parent() {
  this.a = 20
}
var p = new Parent()
console.log(p.a) // 20
```

函数的 this 指向还有一种额外情况，那就是箭头函数。对于箭头函数来说，它的 this 是在它定义的时候就决定了的。它的 this 指向它的父级执行上下文环境的 this。

```js
function fun() {
  let a = 1
  const b = () => {
    console.log(this)
  }
  b()
}
fun() // window
```

这里应该会有个问题就是，箭头函数的 this 在定义的时候确定，普通函数的 this 在调用时确认，那函数里的箭头函数的 this，如果外层函数不调用，岂不是一直不确认了？

其实不是的，也会是在定义的时候确认，只不过 this 指向是一种类似内存存储对象(栈存地址，对象本身存堆)的引用关系。

```js
const obj = {
  hello: 'hello'
}

function fun() {
  let a = 1
  const b = () => {
    console.log(this)
  }
  b()
}
fun.call(obj) // { hello: 'hello' }
```

———

至于更加复杂的情况，就需要看[冴羽大佬的博客](https://github.com/mqyqingfeng/Blog/issues/7)了，比如说：

```js
var value = 1

var foo = {
  value: 2,
  bar: function () {
    return this.value
  }
}

console.log((foo.bar = foo.bar)()) // 1
console.log((false || foo.bar)()) // 1
console.log((foo.bar, foo.bar)()) // 1
```
