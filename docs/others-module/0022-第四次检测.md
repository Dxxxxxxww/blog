1. 姓名

2. 写出输出的结果 （正确率 0%）

```js
// 第一组
const count = 1
const User = {
  count: 2,
  action: {
    getCount: () => {
      return this.count
    }
  }
}
const action = User.action
const getCount = User.action.getCount
Promise.resolve().then(() => {
  setTimeout(() => {
    console.log(action.getCount())
  })
})
setTimeout(() => {
  console.log(User.action.getCount())
})
console.log(getCount())

// undefined  undefined undefined

// 第二组
const count = 1
const User = {
  count: 2,
  action: {
    getCount: function () {
      return this.count
    }
  }
}
const action = User.action
const getCount = User.action.getCount
Promise.resolve().then(() => {
  setTimeout(() => {
    console.log(action.getCount())
  })
})
setTimeout(() => {
  console.log(User.action.getCount())
})
console.log(getCount())
// undefined undefined undefined

// 第三组（这一个很难）
var f = function g() {
  return 23
}
console.log(typeof g())

// 报错 g 没有定义

// 第四组
var y = 1,
  x = (y = typeof x)
console.log(x)

// 'undefined'

// 第五组
console.log(
  (function f(f) {
    return typeof f()
  })(function () {
    return 1
  })
)

// number

// 第六组
var foo = {
  bar: function () {
    return this.baz
  },
  baz: 1
}
;(function () {
  console.log(typeof arguments[0]())
})(foo.bar)

// undefined

// 第七组
var f = (function f() {
  return '1'
},
function g() {
  return 2
})()
console.log(typeof f)

// 逗号表达式，执行逗号前的代码，返回逗号后的，这里返回了函数 g，然后再立即执行，返回2
// number

// 第八组（这一个很难）
var x = 1
if (function f() {}) {
  x += typeof f
}
console.log(x)

// 1function
// 1undefined

// 第九题
function f() {
  return f
}
var g = new f()
console.log(g instanceof f)
console.log(g === f)

// false true
```

3. 请说明以下情况，页面会发生产生什么样的效果（正确率 16.67%）

```html
第一种情况，假定 main.css 是一个很大的文件，那当前页面会呈现出什么样的效果呢？
请描述呈现效果，并说出原因。
<!DOCTYPE html>
<html>
  <head>
    <style>
      p,
      span,
      div {
        color: red;
      }
    </style>
  </head>
  <body>
    <p>p标签</p>
    <span>span标签</span>
    <link rel="stylesheet" type="text/css" href="./main.css" />
    <style>
      p,
      span,
      div {
        color: yellow;
      }
    </style>
    <div>div标签</div>
  </body>
</html>

<!-- 先白屏，再渲染，render tree 的合成需要 css tree 和 dom tree，即便 DOM 已经完成解析，但是 css 文件太，还是需要等待 css 文件解析。等到 dom 解析完成，虽然页面还没渲染， 但是此时可以获取到 dom 元素 -->

第二种情况，假定 main.css 是一个很大的文件，那当前页面会呈现出什么样的效果呢？
请描述呈现效果，并说出原因。
<!DOCTYPE html>
<html>
  <head>
    <style>
      p,
      span,
      div {
        color: red;
      }
    </style>
    <link rel="stylesheet" type="text/css" href="./main.css" />
  </head>
  <body>
    <p>p标签</p>
    <span>span标签</span>
    <style>
      p,
      span,
      div {
        color: yellow;
      }
    </style>
    <div>div标签</div>
  </body>
</html>

<!-- 跟上面一样，只不过会更早的开始css下载解析 -->

第三种情况，假定 main.js 是一个很大的文件，那当前页面会呈现出什么样的效果呢？
请描述呈现效果，并说出原因。
<!DOCTYPE html>
<html>
  <head>
    <style>
      p,
      span,
      div {
        color: red;
      }
    </style>
  </head>
  <body>
    <p>p标签</p>
    <span>span标签</span>
    <script src="./main.js"></script>
    <style>
      p,
      span,
      div {
        color: yellow;
      }
    </style>
    <div>div标签</div>
  </body>
</html>
<!-- 白屏之后在渲染，与上面 css 文件太大不同的是，js文件的加载会阻塞 dom 解析，所以上面css文件过大，dom正常解析完是可以获取到dom元素，而这里不行 -->

第四种情况，假定 main.js 是一个很大的文件，那当前页面会呈现出什么样的效果呢？
请描述呈现效果，并说出原因。
<!DOCTYPE html>
<html>
  <head>
    <style>
      p,
      span,
      div {
        color: red;
      }
    </style>
    <script src="./main.js"></script>
  </head>
  <body>
    <p>p标签</p>
    <span>span标签</span>
    <style>
      p,
      span,
      div {
        color: yellow;
      }
    </style>
    <div>div标签</div>
  </body>
</html>
<!-- 同上 -->

第五种情况，假定 main.js 是一个很大的文件，那当前页面会呈现出什么样的效果呢？
请描述呈现效果，并说出原因。
<!DOCTYPE html>
<html>
  <head>
    <style>
      p,
      span,
      div {
        color: red;
      }
    </style>
  </head>
  <body>
    <p>p标签</p>
    <span>span标签</span>
    <script defer src="./main.js"></script>
    <style>
      p,
      span,
      div {
        color: yellow;
      }
    </style>
    <div>div标签</div>
  </body>
</html>

<!-- 页面不会被 js 阻塞，直接渲染。defer 会并行下载 script，在 dom 解析完成后才执行 script(在 DOMContentLoaded 触发之前)  -->
```

4. 说一下 webpack 模块打包运行原理？Webpack 是如何把这些模块合并到一起，并且保证其正常工作的（正确率 16.67%）

从入口文件开始，检测 import/export ，查找对应的模块，来建立一个依赖关系图。对于非 js 文件就需要借助对应的 loader 来进行处理。将这些依赖的文件整合到 chunk 文件中，最后输出到 output。

5. 利用 webpack 做过什么打包优化（正确率 8.33%）

a. 使用 webpack-bundle-analyzer 先查看包体积，看看那些可以减小。
b. 使用 externals，将一些不常改变的包排除在打包范围外，放到 cdn 上。
c. 配置 splitChunks，针对多次引用的文件单独抽离。配置异步路由组件加载，自动代码分割。

6. 前端监控如何进行数据采集的？如何设计完成前端监控？（正确率 0%）

通过接口上送数据。

在关键接口/按钮处手动设置埋点，或者是通过冒泡，在根节点进行无痕埋点，但是这种需要清洗数据。

我现在项目里只是做了手动埋点，主要是记录一些比较重要的接口的请求参数和关键数据返回值，设置记录时间。监控系统是一个延时队列，由两个参数控制，一个是队列长度，当埋点数量达到 5 个时就进行数据上报，还有就是使用 sendBeacon,requestIdleCallback,promise,setTimeout 做一个类似 vue.$nextTick 的降级处理。

7. React setState 什么情况是同步的？什么情况是异步的？（正确率 41.67%）

[](https://juejin.cn/post/6959885030063603743#heading-6)
[](https://zhuanlan.zhihu.com/p/350332132)

8. 判断 list1 和 list2 是否是子集的关系（正确率 8.33%）

```js
/**

- 判断 list1 和 list2 是否是子集的关系
- @param {number[]} list1 有序数组
- @param {number[]} list2 有序数组
- @return {boolean}
-
- @example
- return true
- isChild([1,3,5], [1,2,3,3,4,5])
-
- @example
- return false
- isChild([1,3,3,5], [1,2,3,4,5])
-
- @example
- return true
- isChild([1,2,3,3,4,5], [1,3,3,5])
  */

function isChild(list1, list2) {
  list1 = [...list1]
  list2 = [...list2]

  const len1 = list1.length
  const len2 = list2.length
  let longer = list1,
    shorter = list2,
    result = true

  if (len1 < len2) {
    longer = list2
    shorter = list1
  }
  const longerMap = {},
    shorterMap = {}
  for (let i = 0; i < longer.length; i++) {
    longerMap[longer[i]] = longerMap[longer[i]] ? ++longerMap[longer[i]] : 1
    const shorterValue = shorter[i]
    if (shorterValue) {
      shorterMap[shorterValue] = shorterMap[shorterValue]
        ? ++shorterMap[shorterValue]
        : 1
    }
  }
  for (const key in shorterMap) {
    const element = shorterMap[key]
    if (element > longerMap[key]) {
      result = false
      break
    }
  }
  return result
}
```

9. amd 和 cmd ，commonjs，es module 的区别（正确率 8.33%）

amd 和 cmd 算是已经淘汰了的技术了，没有了解。
commonjs，es module 的区别：
a. cjs 输出的是值的拷贝，而 esm 输出的是值的引用。当 cmj 模块内部值后续有变化，无法同步更新到外部对这个值的引用。而 esm 可以。
b. cjs 加载的是一个对象，只有在模块脚本运行完才会生成，且只会生成一次。而 esm 它是一种静态定义，在代码静态解析阶段就会生成。这就是为啥 esm 可以进行 tree-shaking。

10. 什么是事件冒泡和事件捕获，区别是什么。（正确率 66.67%）

事件冒泡：IE 事件流。从具体的元素触发，然后向上传播
事件捕获：网景团队提出的。从最不具体的节点出发，然后到具体节点

11. 你最近几次绩效是什么级别？是什么阻碍了你取得更好的绩效？你认为做哪些事情可以取得更好的绩效？（回答的时候严肃一点点哦，请当做正式面试来做）

A-，B，晋升只要 B 以上就可以了，所以下半年可以参加晋升。领导每次谈话都说对我挺满意，对于任务需求我也都是主动去揽活，有优化的地方也会主动跟领导商讨。唯一可能有不足的地方就是对整个业务还不太熟悉，对于实施提出的问题沟通解决不及时。
