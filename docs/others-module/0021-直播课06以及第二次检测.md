
## 2. 请解释什么是事件循环（44.4% 正确率）

因为 js 单线程的模式，为了在 js 中任务可以有序，不阻塞的进行，js 将任务分为宏任务和微任务。事件循环就是一个描述宏微任务如何有序执行的过程。

---

**解答：**看时间循环章节。

宏任务依赖外部的任务队列。

settimeout 的实现 -> 红黑树

## 3. Promise 输出（77.8% 正确率）

```js
console.log('start')

setTimeout(() => {
  console.log('children2')
  Promise.resolve().then(() => {
    console.log('children3')
  })
}, 0)

new Promise(function(resolve, reject) {
  console.log('children4')
  setTimeout(function() {
    console.log('children5')
    resolve('children6')
  }, 0)
}).then(res => {
  console.log('children7')
  setTimeout(() => {
    console.log(res)
  }, 0)
})
```

请给出上述代码的执行结果:

start -> children4 -> children2 -> children3 -> children5 -> children7 -> children6

---

**解答：**

不属于宏任务微任务中的任意一个的，requestidecallback，raf。
requestidecallback 空闲的时候调用。raf，渲染前调用。

执行顺序一定要用数据结构来保证，而不是 eventloop。

一个是标准会修改，一个是像 raf ric 执行时机不固定。

## 4. 请说明浏览器的缓存策略 （38.9% 正确率）
   从强缓存、弱缓存两个维度展开写

   强缓存：不会去向服务器发送请求，在浏览器调试工具中查看状态码 200，并且有显示 from disk 或者 from memory。

   协商缓存：在强缓存失效后，会去向服务器发送请求，如果缓存命中，会返回 304，缓存失效返回 200。

   [浏览器缓存](https://www.jianshu.com/p/54cc04190252)

---

**解答：**

**StaleWhileRevalidate：一个标准/模式/方法。先用旧缓存，后台去异步更新新数据。等下次刷新页面进来才能拿到新数据。晚一次的问题。**

依赖请求头，目前只有 chrome 和 edge 支持，所以可以使用这个库。
swr 策略实现 [swr](https://swr.vercel.app/zh-CN)

antd 文档目前也有这个。阿里的 ahooks 里面已经实现了 swr。

service worker 也可以实现 swr。service worker 使用的 cache api。

Cache-Control

stale-while-revalidate

immutable

stale-if-error

## 5. 请总结前端的存储方案，并对比其优劣势 （22.2% 正确率）

内存存储 vuex redux 等手段：数据存放在内存中，浏览器刷新就会消失。

localstorage，sessionstorage：有大小限制，chrome 最大 5mb。localstorage 刷新/关闭后重新打开网页，数据依然存在。sessionstorage 页面刷新，数据存在。页面关闭后重新打开，数据消失。

cookie: 一般用来存储用户状态，用于后台获取用户状态。保证安全性需要后端设置 httpOnly，不让 js 能获取 cookie。

cookie 可以看冴羽的 cookie。

indexedDB: 浏览器内置的一个数据库。

## 6. 什么是层叠上下文？可以做哪些优化？（27.8% 正确率）

层叠上下文就是，以垂直于屏幕的方向作为 z 轴，css 排列 dom 的前后顺序。

优化：未知。

## 7. 实现 foo 完成如上输出。（50% 正确率）

```js
a = foo()
b = foo()
c = foo()
// a === 1;b === 2;c === 3;
foo.clear()
d = foo()
//d === 1;

function foo() {
  foo.count = foo.count || 1
  foo.clear = () => {
    foo.count = 1
  }
  return foo.count++
}
```

## 8. 请讲一下 v8 的垃圾回收机制（55.6% 正确率）

v8 主要使用分代回收的垃圾回收机制。将内存分为新生代和老生代。新生代空间小，老生代空间大。针对不同代采用不同垃圾回收算法。

对于新生代来说，主要是将空间分为两个部分，通过把还在使用的对象在两个空间内进行复制，进行空间互换，进行垃圾回收，是一种空间换时间的思想。缺点就是浪费了一半的空间。在 64 位操作系统下，新生代空间为 32m。32 位下 16m。

对于老生代来说，使用标记清除，标记整理，增量标记算法来进行垃圾回收。

标记清除就是从根开始进行遍历，标记遍历不到的内存空间，在清除阶段进行清除。

标记整理就是在标记清除的基础上，增加了内存整理的步骤，会将碎片的内存空间合并成连续的内存空间，这样就不会出现内存空间碎片化的问题。

增量标记就是将标记的流程拆分成小流程，与 JS 主线程交替执行，这样避免了在垃圾回收时占用主线程导致卡顿。

**解答：**看 v8 那一章节。

## 9. 请讲一下 React 的 diff 算法（11.1% 正确率）

不会。。

---

**解答：**

## 10. React fiber 是什么？React 如何实现中断重启任务？（5.56% 正确率）

不会。。

---

**解答：**

## 11. 请讲一下浏览器架构及工作原理（17.6% 正确率）

浏览器是一个多进程的软件。比如说，我们打开的每个 tab 页，就都是一个单独的进程。还包括其他插件进程等。

每一个进程下都会有多个线程：

1. GUI 线程；
2. 定时器线程；
3. 事件线程；
4. 网络线程；
5. js 线程。

我们在 js 中使用发送请求时就会用到网络线程，写定时器时就会用到定时器线程，事件触发时就会用到事件线程。

## 12. 请讲一下跨标签页通信有哪些方案？（41.18% 正确率）

不会。。

---

**解答：** postMessage，sharedWorker，BroadcastChanner, localstorage

localstorage 使用方式就是，window.addEventListener("storage", function(e) { console.log(e) })

## 13. 请解释一下 http 及 https 的区别（64.7% 正确率）

https 多了一层安全协议。具体不会。

---

**解答：**SSL/TLS，加密，安全性，端口

## 14. 有什么方案可以优化页面首屏加载速度，请展开讲一讲（29.41% 正确率）
1. 使用路由懒加载，首页上不需要的组件都延迟加载；
1. 针对 lodash 这种第三方工具包做到按需加载；
1. 图片懒加载，现在 html 已默认支持；
1. 使用 ssr；
1. 最重要的，优化首屏的接口速度。

[首屏性能优化参考](https://zhuanlan.zhihu.com/p/56121620)

---

**解答：**

按分类和指标去讲。load, DCL, FP, FCP, FMP, LCP。

[指标](https://www.jianshu.com/p/9a2725c666da)

## 15. new 操作符做了什么？实现一个简版的 new 操作符（64.70% 正确率）

```js
function myNew(constructor, ...args) {
  // Object.create 的模拟实现在下面
  const obj = Object.create(constructor.prototype)
  const res = constructor.apply(obj, args)
  return typeof res === 'object' || typeof res === 'function' ? res : obj
}

function ObjectCreate(p) {
  const obj = {}
  Object.setPrototypeOf(obj, p)
  return obj
}
```

## 16. 实现 Promise.all（58.82% 正确率）

```js
Promise.all2 = function(arr) {
  return new Promise((resolve, reject) => {
    const res = []
    let index = 0
    function addItem(i, v) {
      res[i] = v
      index++
      if (index === arr.length) {
        resolve(res)
      }
    }
    arr.forEach((item, i) => {
      if (item instanceof Promise) {
        item.then(value => addItem(i, value), reject)
      } else {
        addItem(i, item)
      }
    })
  })
}

const p = new Promise((resolve, reject) => {
  setTimeout(() => resolve('成功'), 2000)
  // setTimeout(() => reject("失败"), 2000);
})
const p2 = new Promise((resolve, reject) => {
  resolve('成功222')
  // reject("失败222");
})

Promise.all2([p, 1, 2, p2, 3, 4]).then(
  val => console.log(val),
  err => console.log(err)
)

Promise.all([p, 1, 2, p2, 3, 4]).then(
  val => console.log(val),
  err => console.log(err)
)
```

## 17. 实现 Promise.any（29.41% 正确率）

```js
Promise.any2 = function(arr) {
  return new Promise((resolve, reject) => {
    const rejects = []
    let index = 0

    function check(i, v) {
      rejects[i] = v
      index++
      if (index === rejects.length) {
        reject(rejects)
      }
    }

    arr.forEach((item, i) => {
      // 不是 promise 也包装成 promise
      Promise.resolve(item).then(resolve, err => check(i, err))
    })
  })
}

const p = new Promise((resolve, reject) => {
  // setTimeout(() => resolve('成功'), 2000)
  setTimeout(() => reject('失败'), 2000)
})
const p2 = new Promise((resolve, reject) => {
  // resolve('成功222')
  reject('失败222')
})

Promise.any2([p, p2]).then(
  val => console.log(val),
  err => console.log(err)
)

Promise.any([p, p2]).then(
  val => console.log(val),
  err => console.log(err)
)
```

## 18. 实现斐波那契数列（70.59% 正确率）

指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2)（n>=2，n∈N\*）。

```js
function Fn(n) {
  // if (n === 0) {
  //   return 0
  // }
  // if (n === 1) {
  //   return 1
  // }
  if (n < 2) {
    return n
  }
  return Fn(n - 1) + Fn(n - 2)
}
```

[斐波那契（Fibonacci）算法](https://zhuanlan.zhihu.com/p/34802951)

## 19. 如何加速斐波那契数列函数的执行速度呢？你有哪些优化方案？（64.71% 正确率）

不会。。

---

**解答：**

递归的问题：重复计算，容易爆栈。

1. 递归改循环。
2. 加缓存函数。
3. 尾递归优化。-> 没有中间变量。v8 没有默认开启尾递归优化。


---

window.devicePixelRatio
