bigint  大数危机(数字太大了精度丢失)  

后端 long型 可以处理  9,223,372,036,854,775,807

js Number.MAX_SAFE_INTEGER  9007199254740991   -> 16位    Infinity 无穷。全局字段
Number.MIN_SAFE_INTEGER

bigint 不能计算 float 

js 大数计算，用第三方库 bignumber.js

精度计算，使用 (Math.abs(a - b) < Number.EPSILON); 判断两数是否相等。小数乘法放大成整数计算。

ES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。
对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。
Number.EPSILON === Math.pow(2, -52)

整数十进制转二进制 除二取余。

小数，乘二取整
方法：乘2取整法，即将小数部分乘以2，然后取整数部分，剩下的小数部分继续乘以2，然后取整数部分，剩下的小数部分又乘以2，一直取到小数部分
为零为止。如果永远不能为零，就同十进制数的四舍五入一样，按照要求保留多少位小数时，就根据后面一位是0还是1，取舍，如果是零，舍掉，如果是1，向入一位。换句话说就是0舍1入。读数要从前面的整数读到后面的整数。 所以浮点数会有精度问题。


typeof null 为什么返回 object

在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签是 0，typeof null 也因此返回 "object"。

typeof  可以判断 一个变量是否被声明过. -> 用 let/const 定义的话 就无法判断，因为 变量不在 window 上。 try-catch

```js
// 这样判断不会报错，直接使用会报错
typeof a // undefined

typeof window.a // undefined

let b // undefined

typeof b // undefined

typeof window.b // undefined
```

NaN   isNaN  Number.isNaN() Number.isFinite()

```js
// 如果参数类型不是NaN，Number.isNaN一律返回false。
Number.isNaN(NaN) // true
Number.isNaN(15) // false
Number.isNaN('15') // false
Number.isNaN(true) // false
Number.isNaN(9/NaN) // true
Number.isNaN('true' / 0) // true
Number.isNaN('true' / 'true') // true
```
它们与传统的全局方法 isFinite()和isNaN()的区别在于，**传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效**，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。

in 也可以，只不过 需要把变量加引号。 in 是原型链上都可以

NaN 不是 false NaN != false 但是 NaN || 1  会返回 1 。!!NaN 会返回 false
```js
if (NaN) {
    console.log('这里面不会执行')
}
```
所以 NaN 虽然不等于 false ，但是在条件判断时会被当做 false 处理

堆 -> 树，二叉树，二叉平衡术，大顶堆小顶堆(找最大最小值)

Object 有 数据属性和访问器属性 

数据属性： [[Value]] [[Writable]] [[Enumerable]] [[Configurable]]

访问器属性： get set

文档能力，文档排版


闭包的用途：AOP 面向切面编程 ->   redux 的 compose koa 的洋葱模型。科里化。缓存。

