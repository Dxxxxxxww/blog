## 第一次考试讲解

# 第一次考试

## 请讲一下 JavaScript 的原型与原型链

原型：对于每个 js 普通对象来说，其 \_\_proto\_\_ 指向的对象就是原型对象。对于每个函数来说，其 prototype 指向的对象就是原型对象。
原型链：一个对象的 \_\_proto\_\_ 指向其构造函数的 prototype，然后因为原型对象也是对象，它的 \_\_proto\_\_ 指向其构造函数的 prototype。这样形成的一条链叫做原型链。原型链的重点是 null。

## 用代码实现 bind、apply、call

看手写文件

## 写出本题的输出 变量提升

```js
执行环境以 Chrome 为准
// 第一组
console.log(a);

var a=12;

function fn(){
  console.log(a);
  var a=13;
}

fn();

console.log(a);


// 第二组
console.log(fn);
var fn = 2019;
console.log(fn);
function fn(){}


// 第三组
var a=2;
function a() {
    console.log(3);
}
console.log(typeof a);

// 第四组
if(!("value" in window)){
    var value = 2019;
}
console.log(value);
console.log('value' in window);

// 第五组
console.log(a, b)
var a =12, b ='哈哈'
function foo(){
  	console.log(a, b)
    var a = b =13
    console.log(a, b)
}
foo()
console.log(a, b)

// 第六组
console.log(a, b)
var a =12, b = '哈哈'
function foo(){
    console.log(a, b)
    console.log(a, b)
}
foo()
console.log(a, b)


// 第七组
function foo(o){
 o.pro = 'x';
 o = new Object();
 o.pro = 'y'
}
var obj = new Object();
foo(obj);
console.log(obj.pro)

// 第一组：undefined undefined 12

// 第二组：fn 2019

// 第三组：number

// 第四组：undefined true

// 第五组：undefined,undefined  undefined,哈哈  13,13  12,13

// 第六组：undefined,undefined  12,哈哈 12,哈哈 12,哈哈

// 第七组：x
```

## eventloop 写出以下三组的输出结果

```js
执行环境以 Chrome 为准
// 第一组
async function async1() {
    console.log('async1 start')
    await async2()
    console.log('async1 end')
}
async function async2() {
    console.log('async2')
}
console.log('script start')
setTimeout(function () {
    console.log('setTimeout')
}, 0)
async1()
new Promise((resolve) => {
    console.log('promise1')
    resolve()
}).then(function () {
    console.log('promise2')
})
console.log('script end')

// 第二组
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
async function async2() {
    new Promise(function (resolve) {
        console.log('promise1');
        resolve();
    }).then(function () {
        console.log('promise2');
    });
}
console.log('script start');
setTimeout(function () {
    console.log('setTimeout');
}, 0)
async1();
new Promise(function (resolve) {
    console.log('promise3');
    resolve();
}).then(function () {
    console.log('promise4');
});
console.log('script end');

// 第三组
async function async1() {
    console.log('async1 start');
    await async2();
    setTimeout(function() {
        console.log('setTimeout1')
    },0)
}
async function async2() {
    setTimeout(function() {
        console.log('setTimeout2')
    },0)
}
console.log('script start');
setTimeout(function() {
    console.log('setTimeout3');
}, 0)
async1();
new Promise(function(resolve) {
    console.log('promise1');
    resolve();
}).then(function() {
    console.log('promise2');
});
console.log('script end');

// 第一组：script start, async1 start, async2, promise1, script end, async1 end, promise2, setTimeout

// 第二组：script start,  async1 start,  promise1,  promise3,  script end,  promise2,  async1 end,  promise4,  setTimeout

// 第三组：script start,  async1 start,  promise1,  script end,  promise2,  setTimeout3,  setTimeout2,  setTimeout1
```

## 实现自定义的 instanceof（正确率： 85.71%）

看 instanceof 手写文件

## Nginx 与 CDN 资源缓存有什么不同？（正确率： 35.71%）

nginx 主要是来做负载均衡的。cdn 资源缓存是用来加快用户请求的。这俩不冲突，还可以结合使用。
nginx 是防止服务器压力过大，主动的进行分流。cdn 资源缓存是加快用户对相近节点的请求时间。

## Web 安全你知道那些？描述一下常见的攻击方式及解决方案。（正确率： 35.71%）

1. 跨站脚本攻击 XSS。
   比如说一个评论场景，恶意用户在输入框中输入脚本代码，前后端没有做判断拦截直接存入数据库，当其他用户访问时获取到了这段代码，就会执行。
   解决办法：前后端对用户输入都持不信任态度，进行拦截判断处理，拦截<xx></xx>这样的内容。
2. CSRF。
   比如说用户在登录网站，没有退出，没有关闭的情况下，这时候浏览器还保存着 cookie，访问了其他的恶意网站。由于浏览器只校验目标网站，只要正确就会发送 cookie，所以恶意网站可以使用用户的 cookie 去发起请求进行恶意操作。
   解决办法：
   a. 使用 token，把 token 当做自定义请求头属性放在 HTTP 头中发送。
   b. 使用新版本的 chrome，并将 cookie 的 SameSite 策略改为比较严格的模式。
   c. 使用 Referer，Referer 可被修改，所以不保险。

解答： [安全介绍解决方案集合](https://www.eggjs.org/zh-CN/core/security)

反射型 xss：

虚拟 dom 对 xss 攻击已经有防范了。因为已经通过 vdom 转过一层了，对于一些符号过滤转义过了。

sanitize，浏览器没实现，都用的第三方库，sanitize-html。sanitize-js。

抓包其实就是一种中间人攻击方式。Charles

## 懒加载除了滚轮监听还有什么方法?（正确率： 42.86%） 前端无限滚动问题，长列表问题。

虽然不会，但是还是强行回答一下。对于图片这种资源可以预加载，或者使用雪碧图来加载。对于列表数据的话，进行分页。

解答：

监听滚轮会频繁触发，消耗性能。

intersectionObserver：利用 IntersectionObserver api 当图片出现在用户视口的时候才开始真正加载图片地址。

延伸：MutationObserver 可以用来防止水印被删掉，如果水印元素被删了，可以通过这个监听来再加回来。但是这种方式，可以被禁用 js 来干掉。

## 实现快速排序（正确率： 42.86%）

还没刷算法

---

cdn 回源

cdn 预热 -> cdn pull 模式，需要要求半夜等用户少的时候，并且得不能让所有的 cdn 服务器同时来请求资源。

推荐 cdn push 模式，手动更新代码时提交新资源到 cdn。

s3 bucket 的概念 bulk

[安全介绍解决方案集合](https://www.eggjs.org/zh-CN/core/security)
