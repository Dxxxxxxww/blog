# 异步

## JS 单线程

JS 设计初衷是放在浏览器中执行的，为了保证 dom 操作不会冲突。所以它的执行环境中负责执行 js 代码 的线程只有一个。

[link](https://juejin.cn/post/6844903553795014663)

## Promise

### Promise 的注意事项

对于 promise 来说，值只有两种情况，是 promise，不是 promise。如果是 promise 会使用 then 进行状态判断，如果不是 promise 就直接 resolve 了(即便是一个 Error 对象)。

```js
const p2 = new Promise((resolve, reject) => {
    // resolve("成功222");
    reject("失败2233");
});

p2.then("", err => {
    console.log(err);
    // throw new Error('456') // 输出 errorLo:::: Error: 456
    return new Error("456"); // 输出 hahaha Error: 456
}).then(
    val => {
        console.log("hahaha", val);
    },
    err => {
        console.log("errorLo::::", err);
    }
);
```

```js
axios("/api").then(
    res => {
        throw new Error("异常A");
        // return axios('/api/error') // 这个新的 promise 所产生的异常，then 的第二个参数是捕获不到的
    },
    err => {
        // then 的第二个参数 => catch函数，只能捕获到当前 promise 出现的异常
        // 如果在当前的 promise 中返回了一个新的 promise，并且这个 promise 报错了，这里是无法捕获到的
    }
);

axios("/api")
    .then()
    .catch(err => {
        // 而使用这种方法是全都可以捕获到(当然 catch 中又报错了的话那自然是捕获不到的)
    });
```

### Promise 的实用案例

1. 并行请求

```js
const urls = ["/api/getInfo", "/api/getUser"];

// 返回一个 promise 数组
Promise.all(urls.map(item => axios(item))).then(valList => {
    console.log(valList);
});
```

2. 限制请求时长

```js
const getInfo = axios("/api/getInfo");
const timeout = new Promise((_, reject) => {
    setTimeout(() => reject(new Error("timeout")), 5000);
});

Promise.race([getInfo, timeout])
    .then(val => {
        console.log(val);
    })
    .catch(err => {
        console.log(err);
    });
```

## EventLoop

[最后一次搞懂 Event Loop](https://juejin.cn/post/6844903827611598862)

[Tasks, microtasks, queues and schedules](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)
