# 异步

## JS 单线程

JS 设计初衷是放在浏览器中执行的，为了保证 dom 操作不会冲突。所以它的执行环境中负责执行 js 代码 的线程只有一个。

[link](https://juejin.cn/post/6844903553795014663)

## Promise

### Promise 的注意事项

对于 promise 来说，值只有两种情况，是 promise，不是 promise。如果是 promise 会使用 then 进行状态判断，如果不是 promise 就直接 resolve 了(即便是一个 Error 对象)。

```js
const p2 = new Promise((resolve, reject) => {
    // resolve("成功222");
    reject("失败2233");
});

p2.then("", err => {
    console.log(err);
    // throw new Error('456') // 输出 errorLo:::: Error: 456
    return new Error("456"); // 输出 hahaha Error: 456
}).then(
    val => {
        console.log("hahaha", val);
    },
    err => {
        console.log("errorLo::::", err);
    }
);
```

```js
axios("/api").then(
    res => {
        throw new Error("异常A");
        // return axios('/api/error') // 这个新的 promise 所产生的异常，then 的第二个参数是捕获不到的
    },
    err => {
        // then 的第二个参数 => catch函数，只能捕获到当前 promise 出现的异常
        // 如果在当前的 promise 中返回了一个新的 promise，并且这个 promise 报错了，这里是无法捕获到的
    }
);

axios("/api")
    .then()
    .catch(err => {
        // 而使用这种方法是全都可以捕获到(当然 catch 中又报错了的话那自然是捕获不到的)
    });
```

### Promise 的实用案例

1. 并行请求

```js
const urls = ["/api/getInfo", "/api/getUser"];

// 返回一个 promise 数组
Promise.all(urls.map(item => axios(item))).then(valList => {
    console.log(valList);
});
```

2. 限制请求时长

```js
const getInfo = axios("/api/getInfo");
const timeout = new Promise((_, reject) => {
    setTimeout(() => reject(new Error("timeout")), 5000);
});

Promise.race([getInfo, timeout])
    .then(val => {
        console.log(val);
    })
    .catch(err => {
        console.log(err);
    });
```

## EventLoop

[最后一次搞懂 Event Loop](https://juejin.cn/post/6844903827611598862)

[Tasks, microtasks, queues and schedules](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)

<b>在不同的浏览器下，甚至是同一种浏览器的不同版本中，异步任务的执行顺序都会有差异，也就是说他们的优先级并不是完全固定的。

注意，只是异步任务的优先级会有所不同，这主要还是各个浏览器的问题。

所以 winter 也说了这种题作为面试题极为不合适。</b>

[学习资料 1](https://juejin.cn/post/6844903827611598862#heading-19)

[学习资料 2](https://juejin.cn/post/6844903553795014663#heading-21)

## 一、promise

```js
var p1 = new Promise((resolve, reject) => {
  console.log('promise1')
  resolve('a')
})
  .then((val) => {
    console.log('then11', val)
    new Promise((resolve, reject) => {
      console.log('promise2')
      resolve('b')
    })
      .then((val) => {
        console.log('then21', val)
        return 'c'
      })
      .then((val) => {
        console.log('then23', val)
        Promise.resolve()
          .then(() => {
            console.log('then23里的 then')
            return 'd'
          })
          .then((val) => {
            console.log('then24', val)
            return 'e'
          })
        return 'f'
      })
      .then((val) => {
        console.log('then25', val)
        return 'g'
      })
    return 'z'
  })
  .then((val) => {
    console.log('then12', val)
  })

// 输出
// promise1
// then11 a
// promise2
// then21 b
// then12 z
// then23 c
// then23里的 then
// then25 f
// then24 d

// 这里的 then23，then23里的 then，then25 是同一轮微任务
```

```js
var p2 = new Promise((resolve, reject) => {
  console.log('promise1')
  resolve('a')
})
  .then((val) => {
    console.log('then11', val)
    new Promise((resolve, reject) => {
      console.log('promise2')
      resolve('b')
    })
      .then((val) => {
        console.log('then21', val)
        return 'c'
      })
      .then((val) => {
        console.log('then23', val)
        return Promise.resolve()
          .then(() => {
            console.log('then23里的 then')
            return 'd'
          })
          .then((val) => {
            console.log('then24', val)
            return 'e'
          })
      })
      .then((val) => {
        console.log('then25', val)
        return 'f'
      })
      .then((val) => {
        console.log('then26', val)
        return 'g'
      })
    return 'z'
  })
  .then((val) => {
    console.log('then12', val)
  })

// 输出
// promise1
// then11 a
// promise2
// then21 b
// then12 z
// then23 c
// then23里的 then
// then24 d
// then25 e
// then26 f
// 这里的 then23，then23里的 then 是同一轮微任务
// then24 是下一轮
// then25 由于 return 新的 promise 的原因变为 下下轮
```

上面两段代码的唯一区别是 <code>then23 里的 then</code> 这一个 <code>promise</code> 是否 <code>return</code>。这里其实是 <code>promise</code> 的特性：<b>如果在 '当前 then' 中手动返回一个新的 promise 则会使紧跟着 '当前 then' 之后的 '后 then' 拼接到 '新 Promise 的 then' 末尾（在本代码中指 then25 拼接到 then24 之后）。（个人理解）进入到下一轮 微任务中，而不是本轮。</b>

```js
var p2 = new Promise((resolve, reject) => {
  console.log('promise1')
  resolve('a')
})
  .then((val) => {
    console.log('then11', val)
    return new Promise((resolve, reject) => {
      console.log('promise2')
      resolve('b')
    })
      .then((val) => {
        console.log('then21', val)
        return 'c'
      })
      .then((val) => {
        console.log('then23', val)
        return Promise.resolve()
          .then(() => {
            console.log('then23里的 then')
            return 'd'
          })
          .then((val) => {
            console.log('then24', val)
            return 'e'
          })
      })
      .then((val) => {
        console.log('then25', val)
        return 'f'
      })
      .then((val) => {
        console.log('then26', val)
        return 'g'
      })
  })
  .then((val) => {
    console.log('then12', val)
  })

// 输出
// promise1
// then11 a
// promise2
// then21 b
// then23 c
// then23里的 then
// then24 d
// then25 e
// then26 f
// then12 g
// 同理，then12 变为最后一轮
```
