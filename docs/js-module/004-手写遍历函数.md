# 手写 array 遍历函数

## forEach

```js
Array.prototype.forEach =
  Array.prototype.forEach ||
  function(fn) {
    // 不能使用箭头函数。否则 this 不会指向数组
    const arr = this
    for (let i = 0, len = arr.length; i < len; i++) {
      fn(arr[i], i, arr)
    }
  }
```

## filter

```js
Array.prototype.filter =
  Array.prototype.filter ||
  function(fn) {
    const arr = this,
      result = []
    for (let i = 0, len = arr.length; i < len; i++) {
      const val = arr[i]
      if (fn(val, i, arr)) {
        result.push(val)
      }
    }
    return result
  }
```

## map

```js
Array.prototype.map =
  Array.prototype.map ||
  function(fn) {
    const arr = this,
      result = []
    for (let i = 0, len = arr.length; i < len; i++) {
      const val = arr[i]
      result.push(fn(val, i, arr))
    }
    return result
  }
```

## every

every 返回 false 就会终止遍历

```js
Array.prototype.every =
  Array.prototype.every ||
  function(fn) {
    const arr = this
    let result = true
    for (let i = 0, len = arr.length; i < len; i++) {
      const val = arr[i]
      result = fn(val, i, arr)
      if (!result) {
        break
      }
    }
    return result
  }
```

## some

some 返回 true 就会终止遍历

```js
Array.prototype.some =
  Array.prototype.some ||
  function(fn) {
    const arr = this
    let result = false
    for (let i = 0; i < arr.length; i++) {
      result = fn(arr[i], i, arr)
      if (result) {
        break
      }
    }
    return result
  }
```

## reduce

```js
// 先做环境嗅探
Array.prototype.reduce =
  Array.prototype.reduce ||
  function r2(callback, initVal) {
    // 存一下调用 reduce 的数组
    const arr = this
    // 判断是否传入初始默认值
    const isHasInitVal = arguments.length > 1
    // 如果有默认值取默认值，没有默认值取数组第一位为默认值
    let base = isHasInitVal ? initVal : arr[0]
    // 如果有默认值，数组从 0 开始遍历，如果没有默认值，数组从 1 开始遍历
    const startIndex = isHasInitVal ? 0 : 1
    // 取一下数组
    arr.slice(startIndex).forEach((val, index) => {
      // callback 的参数，上一个值，当前值，当前值的index，数组
      base = callback(base, val, index + startIndex, arr)
    })
    return base
  }
```

## for...of 手写迭代器接口 Symbol.iterator

Symbol.iterator 在语言层面提供了实现迭代器模式的通用可行性。

for...of 可以 break

```js
const obj = {
  store: ['a', 'b', 'c'],
  [Symbol.iterator]() {
    let index = 0
    return {
      next: () => {
        return {
          value: this.store[index++],
          done: index > this.store.length,
        }
      },
    }
  },
}

for (const it of obj) {
  console.log('娃哈哈', it)
}
// 娃哈哈 a
// 娃哈哈 b
// 娃哈哈 c
```

使用 generator 版本

```js
const obj = {
  store: ['a', 'b', 'c'],
  [Symbol.iterator]: function*() {
    for (const item of this.store) {
      yield item
    }
  },
}

for (const it of obj) {
  console.log('娃哈哈', it)
}
// 娃哈哈 a
// 娃哈哈 b
// 娃哈哈 c
```
