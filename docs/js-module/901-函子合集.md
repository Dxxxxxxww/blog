# 函子合集

## 基础函子

```js
class Container {
  static getInstance(value) {
    return new Container(value)
  }
  constructor(value) {
    this._value = value
  }

  map(fn) {
    return Container.getInstance(fn(this._value))
  }
}

const c = Container.getInstance(5)
  .map((x) => x + 1)
  .map((x) => x * x)

console.log(c)
```

## Maybe 函子

相对于基础函子而言增加了对 null, undefined 值的兜底。

```js
class Maybe {
  static of(value) {
    return new Maybe(value)
  }

  constructor(value) {
    this._value = value
  }

  map(fn) {
    return this.isNothing() ? Maybe.of(null) : Maybe.of(fn(this._value))
  }

  isNothing() {
    return this._value === null || this._value === undefined
  }
}
const c = Maybe.of(undefined).map((x) => x * x)

console.log(c) // null
// 如果多次调用 map 方法，无法明确哪一次调用产生了 null 值
```

## Either 函子

相对于 Maybe 函子而言明确了具体报错位置。

```js
class Left {
  static of(value) {
    return new Left(value)
  }

  constructor(value) {
    this._value = value
  }

  map() {
    return this
  }
}

class Right {
  static of(value) {
    return new Right(value)
  }

  constructor(value) {
    this._value = value
  }

  map(fn) {
    return Right.of(fn(this._value))
  }
}

function paseJson(str) {
  try {
    return Right.of(JSON.parse(str))
  } catch (error) {
    return Left.of(error)
  }
}

const p = paseJson('{ "name": "wahaha" }')

console.log(p.map((x) => x.name.toUpperCase()))
```
