# 从简历开始

## 设计模式

观察者 / 发布订阅模式

vue 中 watcher 和 dep 就是观察者模式。发布订阅模式，eventbus，store。

观察者，发布订阅模式的区别

策略模式

策略模式依赖 ooc 中的子类重写父类函数，然后通过一个入口类（或者学名上下文），通过传入不同的子类实例，在入口中设置子类实例，通过子类实例，调用统一的方法，来执行不同子类中相同函数名，逻辑不同的目的。

比如说我们在页面上有一个区域需要渲染四宫格或者九宫格卡片，然后每个卡片内部还会有不同的按钮，这时候我们可以使用 事件委托 + 策略模式 进行逻辑拆分，根据不同的 id， type 来执行不同的逻辑。

或者 table 的各种操作按钮，统一向外提交一个事件，然后不同的参数。

事件委托 再扯到 react 的事件委托

## 说一说你所说的定制项目开发规范，具体是做了什么？

关于这一点，主要是做一些项目的 eslint 配置，配合 perttier 格式化。制定一些文件和代码的命名，编写规范。

举个例子，比如说配置每行末尾都要有逗号。

1. 比如说在一个对象中新增属性时，可能会忘记增加逗号，或者代码合并时因为没有逗号，导致代码合并之后的报错。

文件命名规范，则是都使用“-”，连接符来进行命名，这是借鉴 nextjs 等新型库中的做法。像老的库，vue，react 中其实都是大驼峰命名。用连接符的好处是，

1. 通过 - 隔断单词后，比如说在各种配置文件中匹配文件更方便（eslintrc files 字段， [src/**/*-index.js]）。
2. 看起来更清晰，可以看出组件间的联系：result-list.jsx result-list-item.jsx
3. 与类文件区分

文件命名规范也可以使用 eslint 来配置，但是我没有这么做是因为，这个不太算是强制规范。

代码编写规范。vue 的编写顺序按照 vue/recommend 这个 eslint 包的顺序来做的，options 中的各个属性的编写顺序。

还有就是 if 提前退出这种，减少嵌套。

## 打包相关

我们的低代码系统中有设计各种不同的组件库，然后就会涉及到组件库的打包。现在有了 GPT 的帮助，其实打包配置还是比较方便的。通过 rollup 来打包。

打包组件支持全量引入和按需引入。每个组件都要有自己单独的入口 index.js

打包相关还可以展开：

rollup 和 webpack 的对比

## 项目

### 低代码，无代码系统

看下项目

pnpm 与 npm 对比

1. pnpm 更小，因为依赖都是安装在同一个地方。
2. 速度更快，避免了重复包的重复安装，速度更快
3. 解决幽灵依赖，PNPM 使用严格的依赖关系管理方式，确保项目只能够访问自身声明的依赖，从而避免了“幽灵依赖”（即项目能够访问并使用它未直接声明的依赖包）问题。
4. 原生支持 monorepo

幽灵依赖：是指在项目中，某些包没有直接声明为项目的依赖项，但因为其他依赖包（即间接依赖）把它们安装到了 node_modules 中，项目可以正常使用这些未声明的包。这种情况可能导致不易察觉的依赖隐患。

幽灵依赖会导致以下问题：

依赖不一致：当 PackageB 停止依赖 lodash 或升级时，lodash 可能会被移除或版本发生变化，导致项目报错。
不可预测性：开发人员容易忽略某些依赖，导致在开发环境和生产环境中出现不一致的情况，尤其是在 CI/CD 或不同的团队中使用时。
升级和迁移问题：因为项目未声明这些依赖，当团队或工具需要更新或迁移项目时，可能会出现未预料到的依赖缺失问题。

锁版本:1. 包前的符号去掉 2. package 里面增加 override(npm) 或者 resolution(yarn)字段。pnpm 两种字段都有。这种方式是让第三方依赖中如果有相同依赖的版本也统一

monorepo

优点：

1. 统一管理不同模块中引入相同包的版本，避免不同模块使用不同版本的依赖库
2. eslint prettier 配置方便且一致
3. 提升代码复用率，都在同一个项目中，方便拆分和引入。

### aigc

使用 typedjs 实现打字机效果

react 源码  schedule  lane，事件机制

zustand 源码

immer 源码

### 监控 \*复习下

当时使用 ts 来做主要是想用 ts 来练手。然后使用 monorepo 是为了拆分监控核心和不同平台（vue，react）的代码，解耦操作。

错误上送立即上送，普通的通过 sendBeacon -> requestIdleCallback -> setTimeout 降级上送。 sendBeacon 在低版本安卓下无法使用

[sendBeacon](https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon)

借助 vue 响应式思想，observe 上送队列，长度到了 10 之后就发起上送，就是在想要监控的数据接口处，通过封装好的 axios api，想要监控的话就传一个参数，然后会把这个接口 url，参数，时间给记录下来，然后通过刚刚说的异步上送。

SourceMapDevToolPlugin 这个应该是配置改域名，在公司内的内网域名下可以看到 sourcemap。

数据重复如何区分？ 时间戳+用户 id+url+参数 json 化 形成的一个 id

### pda 业务

这个的话其实是使用 cordova + vue 来搞的，然后一些原生能力是有安卓的同事来提供。比如说把一些方法挂 window 上。
