# JS 性能优化

[查看 js 性能优化的网站](https://jsbench.me/)

## 内存管理

### 内存介绍

内存：由读写单元组成，表示一片可操作的空间。

进程：是 cpu 资源分配的最小单位，系统会给它分配内存。

线程：是 cpu 调度的最小单位

## js 垃圾回收

当一片内存空间没有变量引用，变成不可达到的空间时，就会被 js 进行垃圾回收。

### 常见 GC 算法

1. 引用计数，通过数字来判断是否需要回收；
2. 可达性分析算法：标记清除，给正在使用的对象(空间)打上标记，来判断是否需要回收；
3. 标记整理，与标记清除类似，只不过在回收时有差异；
4. 分代回收，V8。

#### 引用计数原理

通过引用计数器，设置引用数，如果为 0 表示没有引用，则可以进行回收。<b>核心是引用数是否为 0。</b>

优点：

1. 发现垃圾时立即回收；
2. 最大限度减少程序暂停。由于引用计数器一直监视着引用为 0 的对象，所以当内存即将到达瓶颈时，就会立即回收这些对象，减少程序暂停的频率。

缺点：

1. 无法回收循环引用的对象；

```js
const fn = () => {
  const obj1 = {},
    obj2 = {}
  obj1.next = obj2
  obj2.prev = obj1
}
```

2. 时间开销大。引用计数器的存在，需要时刻监视对象的引用计数是否需要更改，并且修改引用数值也需要耗时，对象越多，需要的操作也越多，时间开销越大。

#### 标记清除

标记清除会分为两个阶段，标记和清除。
从 GC Roots(全局) 出发，在标记阶段，会遍历所有对象，给活动的对象打上标记(标记为可达)。在清除阶段，会遍历所有对象，回收没有标记的对象(不可达的对象)，并且会将上一步打上的标记抹除，便于下次工作。

如何解决循环引用？

![image](/performance/bjqc.png)

如图，当两个对象除了彼此引用外，在一个作用域链上，在 GC Roots(全局) 向下搜索无法达到这两个对象时，这两个对象就可以被回收。<b>所以标记清除的核心是 GC Roots(全局) 是否可达对象。</b>

如何判断一个对象是否是可达的呢？

比如说当函数 sayHi 在执行时，sayHi 在执行栈中存在，全局就有这个函数的引用，内部的变量自然是可以达到的。而当 sayHi 执行完出栈后，全局就无法达到内部的变量了。

```js
const sayHi = () => {
  const a = 'a'
}

// 在这里执行是，内部的 a 是可以访问到的
sayHi()
// sayHi 执行完了，内部的 a 无法达到
```

优点：

1. 可以解决循环引用；

缺点：

1. 空间碎片化，当回收的对象在地址上是不连续的，由于是不连续的，在垃圾回收后，空闲区域就会分散在各个角落。而在后续使用这些空闲区域时，如果大小刚好就能直接使用，如果大小不合适就不能使用了，造成了内存浪费；
2. 在遍历的过程中即使发现了一个对象是不可达的，也不会立即去回收也要等到最后才去清除，并且当去清除的时候，程序是停止工作的。

#### 标记整理

可以理解为是标记清除的升级版，在清除阶段会先将对象进行整理，移动对象位置，然后成块的回收垃圾，解决空间碎片化的问题。

### v8 垃圾回收策略

采用分代回收的思想，将内存分为新生代和老生代。针对不同代采用不同算法。

新生代：复制算法，标记整理。

- 新生代内存 64 位系统下是 32m ,32 位系统下是 16m
- 空间复制的时候产生 From 和 To 二个等大小的空间，始终有一部分是空间不使用的，即使很小也是一种浪费，属于用空间换时间。

老生代：标记清除，标记整理，增量标记。

- 老生代内存 64 位系统下是 1.4G ,32 位系统下是 700M

### 监控内存的几种方式

1. 浏览器任务管理器；
2. timeline 时序图记录；
3. 堆快照查找分离 dom；
4. 判断是否存在频繁的垃圾回收。

#### 浏览器任务管理器

浏览器任务管理器 主要查看两列内存，一列是 dom 内存，一列是 JavaScript 内存。查看 dom 内存变动可知当前页面 dom 节点是否在新增/删除。查看 JavaScript 内存可知是否有内存泄漏情况。

#### timeline 时序图

就是性能标签里打开录制后的图形界面。

#### 堆快照查找分离 dom

内存标签里的堆快照。在执行某些操作前，后各拍一次快照。然后通过搜索 detach 来查找是否有分离 dom。

分离 dom 就是一种内存泄漏。

分离状态的 dom：指的是不在界面上显示，也不在 dom 树上，但是还在被对象引用着的 dom 节点。

#### GC 是否频繁的执行

查看 timeline 中是否存在频繁的上升下降。查看任务管理器中内存数值是否频繁的增加减小。
