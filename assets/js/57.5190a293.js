(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{260:function(e,t,r){"use strict";r.r(t);var s=r(0),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"react-零碎待整理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-零碎待整理"}},[e._v("#")]),e._v(" react 零碎待整理")]),e._v(" "),r("h2",{attrs:{id:"过时的生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#过时的生命周期"}},[e._v("#")]),e._v(" 过时的生命周期")]),e._v(" "),r("h3",{attrs:{id:"componentwillreceiveprops"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#componentwillreceiveprops"}},[e._v("#")]),e._v(" componentWillReceiveProps")]),e._v(" "),r("p",[e._v("官方文档：如果父组件导致组件重新渲染，即使 props 没有更改，也会调用 componentWillReceiveProps 方法。如果只想处理更改，请确保当前值与变更值的比较。")]),e._v(" "),r("p",[e._v("结论："),r("b",[e._v("componentWillReceiveProps 并不是由 props 的变化触发的，而是由父组件的更新触发的。")])]),e._v(" "),r("h2",{attrs:{id:"类组件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#类组件"}},[e._v("#")]),e._v(" 类组件")]),e._v(" "),r("p",[e._v("类组件的事件在 render 中需要用 箭头函数包裹一层是为了确保 this 的指向。所以定义函数的时候直接使用箭头函数的话，在 render 中就不需要额外使用箭头函数包裹了。")])])}),[],!1,null,null,null);t.default=a.exports}}]);