(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{272:function(t,e,r){"use strict";r.r(e);var a=r(0),v=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"vue-响应式原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue-响应式原理"}},[t._v("#")]),t._v(" vue 响应式原理")]),t._v(" "),r("p",[t._v("我们知道，vue 是一个数据驱动的框架，在使用时，只需要关注数据的变化。框架本身会处理数据改变引起的视图改变。而 vue 能做到这一点的原理就是使用了 Object.defineProperty 做数据劫持，在获取和设置值的时候做一些事情。")]),t._v(" "),r("h2",{attrs:{id:"前置概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前置概念"}},[t._v("#")]),t._v(" 前置概念")]),t._v(" "),r("h3",{attrs:{id:"object-defineproperty"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#object-defineproperty"}},[t._v("#")]),t._v(" Object.defineProperty")]),t._v(" "),r("h4",{attrs:{id:"proxy-与-object-defineproperty-的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#proxy-与-object-defineproperty-的区别"}},[t._v("#")]),t._v(" proxy 与 Object.defineProperty 的区别")]),t._v(" "),r("ol",[r("li",[r("p",[t._v("在 3.x 中使用了 proxy 来做响应式的处理，由于 proxy 可以直接对整个对象进行设置，所以在代码层面来说会更简洁一些。如果使用 Object.defineProperty 还需要遍历对象的键再做处理。")])]),t._v(" "),r("li",[r("p",[t._v("浏览器对 proxy 做了性能优化，所以 proxy 的性能比 Object.defineProperty 要好。")])])]),t._v(" "),r("h3",{attrs:{id:"发布订阅模式和观察者模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#发布订阅模式和观察者模式"}},[t._v("#")]),t._v(" 发布订阅模式和观察者模式")]),t._v(" "),r("p",[t._v("这两种模式本质相同，在实现上有着细微的差别。")]),t._v(" "),r("h4",{attrs:{id:"发布订阅模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#发布订阅模式"}},[t._v("#")]),t._v(" 发布订阅模式")]),t._v(" "),r("p",[t._v("发布订阅模式，发布者和订阅者都通过事件中心来沟通，彼此之间没有依赖关系。例如：买房-中介平台-卖家 的关系。\n在 vue 中通过使用 $on, $evetn 创建 vue 的自定义事件，eventbus，就是一种发布订阅模式。")]),t._v(" "),r("h4",{attrs:{id:"观察者模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#观察者模式"}},[t._v("#")]),t._v(" 观察者模式")]),t._v(" "),r("p",[t._v("观察者：")]),t._v(" "),r("ul",[r("li",[t._v("update：当事件发生时需要处理的方法。")])]),t._v(" "),r("p",[t._v("发布者：")]),t._v(" "),r("ul",[r("li",[t._v("subs：存储所有观察者。")]),t._v(" "),r("li",[t._v("addSubs：添加观察者。")]),t._v(" "),r("li",[t._v("notify：当事件发生时，调用所有观察者的处理事件方法(update)。")])]),t._v(" "),r("p",[t._v("只有观察者和被观察对象，没有事件中心，彼此之间有依赖关系。vue 的响应式就是用的观察者模式。")]),t._v(" "),r("h2",{attrs:{id:""}},[r("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])])])}),[],!1,null,null,null);e.default=v.exports}}]);