(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{269:function(t,s,a){"use strict";a.r(s);var h=a(0),r=Object(h.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"vue-路由总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-路由总结"}},[t._v("#")]),t._v(" vue 路由总结")]),t._v(" "),a("h2",{attrs:{id:"hash-模式-与-history-模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash-模式-与-history-模式"}},[t._v("#")]),t._v(" hash 模式 与 history 模式")]),t._v(" "),a("ul",[a("li",[t._v("hash：基于锚点，以及 onhashchange 事件。")]),t._v(" "),a("li",[t._v("history：基于 html5 中的 history api。history.pushState, history.replaceState。")])]),t._v(" "),a("h3",{attrs:{id:"history-api-简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#history-api-简介"}},[t._v("#")]),t._v(" history api 简介")]),t._v(" "),a("p",[t._v("输入网址就是个去服务端查找文件的过程。使用 history.pushState 方法会在历史中添加一条记录。只会改变地址栏地址，不会发起请求去服务端查找文件，导致页面跳转。ie10 才开始支持。")]),t._v(" "),a("p",[t._v("而 history.back、history.forward、history.go 方法是会导致页面跳转。")]),t._v(" "),a("h3",{attrs:{id:"history-需要后端配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#history-需要后端配置"}},[t._v("#")]),t._v(" history 需要后端配置")]),t._v(" "),a("p",[t._v("这也就解释了为什么 history 模式为什么需要服务端配置。因为需要服务端配置除了静态资源以外都返回单页应用的 index.html。用以拦截用户在地址栏的任意输入，让页面不会跳转到其他不存在的页面导致 404 错误。")]),t._v(" "),a("p",[t._v("vue cli 创建的服务器已经设置了对 history 模式的支持。")]),t._v(" "),a("h3",{attrs:{id:"history-模式具体流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#history-模式具体流程"}},[t._v("#")]),t._v(" history 模式具体流程")]),t._v(" "),a("p",[t._v("当我们使用 history 模式，服务端开启了 history 的支持。在浏览器上刷新页面，会去服务端请求对应地址文件，如果服务端没有找到对应文件，则会返回 index.html 文件。在我们客户端上拿到了 index.html 文件，并且发现地址栏的地址并不是 index，就会通过路由去找到对应组件。以下是例子：")]),t._v(" "),a("ol",[a("li",[t._v("浏览器刷新，去请求 https://localhost:3000/about；")]),t._v(" "),a("li",[t._v("服务端找不到 about 文件，默认返回 index；")]),t._v(" "),a("li",[t._v("浏览器拿到 index 文件，并且地址栏还是 about，就会去找 about 组件。")])])])}),[],!1,null,null,null);s.default=r.exports}}]);